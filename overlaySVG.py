#!/usr/bin/env python3
"""
Create a pure overlay SVG (just translucent rectangles) to sit on top of an
existing base table SVG generated by your CLI.

Usage examples (from repo root):

  # Highlight row index 2 (3rd row), in Robin
  python highlightSVG.py Scott.svg --rows 2 --color Robin

  # Highlight rows 2, 4, 5 in Tea
  python highlightSVG.py Scott.svg --rows 2 4 5 --color Tea

  # Highlight columns 1 and 3 (0-based) in Cinnabar
  python highlightSVG.py Scott.svg --cols 1 3 --color Cinnabar

  # Highlight specific cells (row,col pairs)
  python highlightSVG.py Scott.svg --cell 2 3 --cell 4 1 --color Robin

The output is an SVG with the SAME width/height/viewBox, but containing ONLY
the highlight <rect> overlays (no original lines/text/etc.).
"""

import argparse
from pathlib import Path
import xml.etree.ElementTree as ET
from typing import List, Tuple, Dict, Optional

# --- Color palette (same naming as your generator) ------------------------

PALETTE: Dict[str, str] = {
    "oxford": "rgb(16,29,62)",
    "cinnabar": "rgb(236,74,39)",
    "persian": "rgb(198,62,48)",
    "cadet": "rgb(155,184,193)",
    "robin": "rgb(52,192,206)",
    "columbia": "rgb(203,216,221)",
    "tea": "rgb(221,232,185)",
    "alabaster": "rgb(229,230,217)",
}


def resolve_color(name: str) -> str:
    key = name.replace(" ", "").lower()
    if key not in PALETTE:
        raise ValueError(
            f"Unknown color '{name}'. Use one of: "
            + ", ".join(sorted(PALETTE.keys()))
        )
    return PALETTE[key]


# --- SVG layout reverse-engineering ---------------------------------------

SVG_NS = "http://www.w3.org/2000/svg"
NS = {"svg": SVG_NS}


def _parse_float(val: Optional[str]) -> float:
    if val is None:
        return 0.0
    return float(val)


def detect_svg_size_and_viewbox(root: ET.Element) -> Tuple[float, float, Optional[str]]:
    """
    Infer svg width/height from viewBox if possible, else width/height attributes.
    Also return the original viewBox string (or None).
    """
    view_box = root.get("viewBox")
    if view_box:
        parts = view_box.replace(",", " ").split()
        if len(parts) == 4:
            _, _, w, h = parts
            return float(w), float(h), view_box

    width = _parse_float(root.get("width"))
    height = _parse_float(root.get("height"))
    return width, height, view_box


def detect_row_layout(root: ET.Element) -> Tuple[float, float, int]:
    """
    Detect header_divider_y, row_height, num_rows from horizontal rule lines.

    Uses the thin row-divider stroke-width group (Cadet/Persian) that your
    generator produces (1pt ~ smallest positive stroke width).
    """
    horizontals = []
    for line in root.findall(".//svg:line", NS):
        y1 = _parse_float(line.get("y1"))
        y2 = _parse_float(line.get("y2"))
        if abs(y1 - y2) < 1e-3:  # horizontal
            stroke_width = _parse_float(line.get("stroke-width"))
            stroke = (line.get("stroke") or "").strip()
            horizontals.append((y1, stroke_width, stroke))

    if not horizontals:
        raise RuntimeError("No horizontal lines found; cannot infer row layout.")

    # Smallest positive stroke width = row/cell dividers
    widths = sorted({sw for (_, sw, _) in horizontals if sw > 0})
    if not widths:
        raise RuntimeError("No positive stroke-widths found among lines.")
    row_sw = widths[0]

    # All y positions of lines with that stroke-width and y>0 (ignore top rule at y=0)
    ys = sorted({y for (y, sw, _) in horizontals if abs(sw - row_sw) < 1e-6 and y > 0})

    if len(ys) < 2:
        raise RuntimeError("Not enough horizontal dividers detected to infer rows.")

    header_divider_y = ys[0]
    data_dividers = ys[1:]
    num_rows = len(data_dividers)
    row_height = data_dividers[0] - header_divider_y

    return header_divider_y, row_height, num_rows


def detect_column_boundaries(root: ET.Element, svg_width: float) -> Tuple[List[float], List[float]]:
    """
    Infer column boundaries from header <text class="header"> positions:
    - Use x positions as centers
    - Boundaries are midpoints between centers; leftmost is 0, rightmost is svg_width.
    """
    header_centers: List[float] = []
    for text in root.findall(".//svg:text", NS):
        cls = text.get("class") or ""
        if "header" in cls:
            x = _parse_float(text.get("x"))
            header_centers.append(x)

    if not header_centers:
        raise RuntimeError("No header text elements found (class='header').")

    header_centers = sorted(header_centers)
    n = len(header_centers)

    col_start_x: List[float] = []
    col_end_x: List[float] = []

    for i in range(n):
        if i == 0:
            start = 0.0
        else:
            start = 0.5 * (header_centers[i - 1] + header_centers[i])

        if i == n - 1:
            end = svg_width
        else:
            end = 0.5 * (header_centers[i] + header_centers[i + 1])

        col_start_x.append(start)
        col_end_x.append(end)

    return col_start_x, col_end_x


# --- Overlay creation -----------------------------------------------------

def add_row_overlays(
    root: ET.Element,
    rows: List[int],
    color_rgb: str,
    header_divider_y: float,
    row_height: float,
    num_rows: int,
    svg_width: float,
    opacity: float = 0.5,
):
    for r in rows:
        if r < 0 or r >= num_rows:
            print(f"Warning: row index {r} out of range [0, {num_rows-1}], skipping.")
            continue

        row_top = header_divider_y + row_height * r
        rect = ET.Element(
            f"{{{SVG_NS}}}rect",
            {
                "x": "0",
                "y": f"{row_top}",
                "width": f"{svg_width}",
                "height": f"{row_height}",
                "fill": color_rgb,
                "fill-opacity": str(opacity),
            },
        )
        root.append(rect)


def add_column_overlays(
    root: ET.Element,
    cols: List[int],
    color_rgb: str,
    header_divider_y: float,
    row_height: float,
    num_rows: int,
    col_start_x: List[float],
    col_end_x: List[float],
    opacity: float = 0.5,
):
    for c in cols:
        if c < 0 or c >= len(col_start_x):
            print(f"Warning: col index {c} out of range [0, {len(col_start_x)-1}], skipping.")
            continue

        x = col_start_x[c]
        width = col_end_x[c] - col_start_x[c]
        y = header_divider_y
        height = row_height * num_rows

        rect = ET.Element(
            f"{{{SVG_NS}}}rect",
            {
                "x": f"{x}",
                "y": f"{y}",
                "width": f"{width}",
                "height": f"{height}",
                "fill": color_rgb,
                "fill-opacity": str(opacity),
            },
        )
        root.append(rect)


def add_cell_overlays(
    root: ET.Element,
    cells: List[Tuple[int, int]],
    color_rgb: str,
    header_divider_y: float,
    row_height: float,
    num_rows: int,
    col_start_x: List[float],
    col_end_x: List[float],
    opacity: float = 0.5,
):
    for (r, c) in cells:
        if r < 0 or r >= num_rows:
            print(f"Warning: row index {r} out of range [0, {num_rows-1}], skipping cell ({r},{c}).")
            continue
        if c < 0 or c >= len(col_start_x):
            print(f"Warning: col index {c} out of range [0, {len(col_start_x)-1}], skipping cell ({r},{c}).")
            continue

        row_top = header_divider_y + row_height * r
        x = col_start_x[c]
        width = col_end_x[c] - col_start_x[c]

        rect = ET.Element(
            f"{{{SVG_NS}}}rect",
            {
                "x": f"{x}",
                "y": f"{row_top}",
                "width": f"{width}",
                "height": f"{row_height}",
                "fill": color_rgb,
                "fill-opacity": str(opacity),
            },
        )
        root.append(rect)


# --- Naming and CLI -------------------------------------------------------

def build_output_name(
    base_svg: Path,
    rows: List[int],
    cols: List[int],
    cells: List[Tuple[int, int]],
    color_name: str,
) -> Path:
    """
    Create a descriptive output filename like:
      Scott_overlay_rows_2_4_5_Robin.svg
    """
    base = base_svg.stem
    parts = [base, "overlay"]

    if rows:
        parts.append("rows_" + "_".join(str(r) for r in rows))
    if cols:
        parts.append("cols_" + "_".join(str(c) for c in cols))
    if cells:
        parts.append("cells_" + "_".join(f"{r}-{c}" for (r, c) in cells))

    parts.append(color_name)
    name = "_".join(parts) + ".svg"
    return base_svg.with_name(name)


def main():
    parser = argparse.ArgumentParser(
        description="Create a highlight overlay SVG (rectangles only) for an existing table SVG."
    )
    parser.add_argument("svg_file", help="Input base SVG file (e.g., Scott.svg)")

    parser.add_argument(
        "--rows",
        nargs="+",
        type=int,
        help="0-based row indices to highlight (e.g., --rows 2 4 5)",
    )
    parser.add_argument(
        "--cols",
        nargs="+",
        type=int,
        help="0-based column indices to highlight (e.g., --cols 1 3)",
    )
    parser.add_argument(
        "--cell",
        nargs=2,
        action="append",
        metavar=("ROW", "COL"),
        help="Highlight a specific cell (0-based row, col). Can be repeated: --cell 2 3 --cell 4 1",
    )
    parser.add_argument(
        "--color",
        default="Tea",
        help="Highlight color name (default: Tea). Options: "
             + ", ".join(sorted(PALETTE.keys())),
    )
    parser.add_argument(
        "--opacity",
        type=float,
        default=0.5,
        help="Fill opacity for overlays (default: 0.5 for 50%).",
    )

    args = parser.parse_args()

    # Default base SVG folder: repo_root/tablejsons/svg
    DEFAULT_SVG_DIR = Path(__file__).resolve().parent / "tablejsons" / "svg"

    svg_arg = args.svg_file
    svg_path = DEFAULT_SVG_DIR / svg_arg


    if not svg_path.exists():
        raise FileNotFoundError(f"SVG file not found: {svg_path}")

    rows = args.rows or []
    cols = args.cols or []
    cells: List[Tuple[int, int]] = []
    if args.cell:
        for (r_str, c_str) in args.cell:
            cells.append((int(r_str), int(c_str)))

    if not rows and not cols and not cells:
        raise ValueError("You must specify at least one of --rows, --cols, or --cell.")

    color_rgb = resolve_color(args.color)
    color_name_clean = args.color.replace(" ", "")

    # Parse the ORIGINAL SVG (for geometry only)
    ET.register_namespace("", SVG_NS)  # ensure xmlns is written exactly once
    tree = ET.parse(svg_path)
    orig_root = tree.getroot()

    svg_width, svg_height, view_box = detect_svg_size_and_viewbox(orig_root)
    if svg_width <= 0 or svg_height <= 0:
        raise RuntimeError("Unable to determine SVG width/height.")

    header_divider_y, row_height, num_rows = detect_row_layout(orig_root)
    col_start_x, col_end_x = detect_column_boundaries(orig_root, svg_width)

    # Create a NEW SVG root that only contains overlays
    overlay_root = ET.Element(
        f"{{{SVG_NS}}}svg",
        {
            "width": str(svg_width),
            "height": str(svg_height),
        },
    )
    if view_box:
        overlay_root.set("viewBox", view_box)

    # Add overlay rectangles
    if rows:
        add_row_overlays(
            overlay_root,
            rows,
            color_rgb,
            header_divider_y,
            row_height,
            num_rows,
            svg_width,
            opacity=args.opacity,
        )

    if cols:
        add_column_overlays(
            overlay_root,
            cols,
            color_rgb,
            header_divider_y,
            row_height,
            num_rows,
            col_start_x,
            col_end_x,
            opacity=args.opacity,
        )

    if cells:
        add_cell_overlays(
            overlay_root,
            cells,
            color_rgb,
            header_divider_y,
            row_height,
            num_rows,
            col_start_x,
            col_end_x,
            opacity=args.opacity,
        )

    # Build output filename in the same folder as the base SVG
    out_path = build_output_name(svg_path, rows, cols, cells, color_name_clean)
    overlay_tree = ET.ElementTree(overlay_root)
    overlay_tree.write(out_path, encoding="utf-8", xml_declaration=True)
    print(f"Overlay-only SVG written to: {out_path}")


if __name__ == "__main__":
    main()
